#pragma once
#include "Environment.hpp"

Environment* Environment::singleton = nullptr;

auto Environment::getSingleton() -> Environment* {
	if (!singleton)
		singleton = new Environment();

	return singleton;
}

auto getProcessId(std::string_view processName) -> std::intptr_t {
	PROCESSENTRY32 entry;
	entry.dwSize = sizeof(PROCESSENTRY32);

	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

	if (Process32First(snapshot, &entry) == 1) {
		while (Process32Next(snapshot, &entry) == 1) {
			if (_stricmp(entry.szExeFile, processName.data()) == 0) {
				CloseHandle(snapshot);
				return entry.th32ProcessID;
			}
		}
	}

	CloseHandle(snapshot);
	return 0;
}

auto isRobloxActive() -> bool {
	std::intptr_t proc_id = getProcessId("Windows10Universal");
	HWND foreground = GetForegroundWindow();

	DWORD fproc_id{};
	GetWindowThreadProcessId(foreground, &fproc_id);

	return (fproc_id == proc_id);
}

auto readFile(std::string file_location) -> std::string {
	auto close_file = [](FILE* f) { fclose(f); };
	auto holder = std::unique_ptr<FILE, decltype(close_file)>(fopen(file_location.c_str(), "rb"), close_file);

	if (!holder)
		return "";

	FILE* f = holder.get();

	if (fseek(f, 0, SEEK_END) < 0)
		return "";

	const long size = ftell(f);

	if (size < 0)
		return "";

	if (fseek(f, 0, SEEK_SET) < 0)
		return "";

	std::string res;
	res.resize(size);
	fread(const_cast<char*>(res.data()), 1, size, f);

	return res;
}

auto replace(std::string subject, std::string search, std::string replace) -> std::string {
	std::size_t pos{};

	while ((pos = subject.find(search, pos)) != std::string::npos) {
		subject.replace(pos, search.length(), replace);
		pos += replace.length();
	}

	return subject;
}

auto equalsIgnoreCase(std::string_view a, std::string_view b) -> bool {
	return std::equal(a.begin(), a.end(),
		b.begin(), b.end(),
		[](char a, char b) {
			return tolower(a) == tolower(b);
		}
	);
}

auto getgenv(lua_State* L) -> std::intptr_t {
    lua_pushvalue(L, LUA_GLOBALSINDEX);
    return 1;
}

auto getreg(lua_State* L) -> std::intptr_t {
    lua_pushvalue(L, LUA_REGISTRYINDEX);
    return 1;
}

auto getrawmetatable(lua_State* L) -> std::intptr_t {
    luaL_checkany(L, 1);

    if (!lua_getmetatable(L, 1))
        lua_pushnil(L);

    return 1;
}

auto setrawmetatable(lua_State* L) -> std::intptr_t {
    luaL_checkany(L, 1);

    std::intptr_t t = lua_type(L, 2);
    luaL_argcheck(L, t == LUA_TNIL || t == LUA_TTABLE, 2, "nil or table expected");

    lua_settop(L, 2);
    lua_pushboolean(L, lua_setmetatable(L, 1));

    return 1;
}

auto setreadonly(lua_State* L) -> std::intptr_t {
    luaL_checktype(L, 1, LUA_TTABLE);
    luaL_checktype(L, 2, LUA_TBOOLEAN);

    Table* t = (Table*)lua_topointer(L, 1);
    t->readonly = lua_toboolean(L, 2);

    return 0;
}

auto isreadonly(lua_State* L) -> std::intptr_t {
    luaL_checktype(L, 1, LUA_TTABLE);

    Table* t = (Table*)lua_topointer(L, 1);
    lua_pushboolean(L, t->readonly);

    return 1;
}

auto iswriteable(lua_State* L) -> std::intptr_t {
    luaL_checktype(L, 1, LUA_TTABLE);

    Table* t = (Table*)lua_topointer(L, 1);
    lua_pushboolean(L, !t->readonly);

    return 1;
}

auto makereadonly(lua_State* L) -> std::intptr_t {
    luaL_checktype(L, 1, LUA_TTABLE);

    Table* t = (Table*)lua_topointer(L, 1);
    t->readonly = TRUE;

    return 0;
}

auto makewriteable(lua_State* L) -> std::intptr_t {
    luaL_checktype(L, 1, LUA_TTABLE);

    Table* t = (Table*)lua_topointer(L, 1);
    t->readonly = FALSE;

    return 0;
}

auto getnamecallmethod(lua_State* L) -> std::intptr_t {
    if (L->namecall != nullptr) {
        lua_pushstring(L, L->namecall->data);
        return 1;
    }

    return 0;
}

auto setnamecallmethod(lua_State* L) -> std::intptr_t {
    luaL_checktype(L, 1, LUA_TSTRING);
    L->namecall = tsvalue(luaA_toobject(L, 1));

    return 0;
}

auto getfps(lua_State* L) -> std::intptr_t {
    auto taskScheduler{ TaskScheduler::getSingleton() };
    lua_pushinteger(L, taskScheduler->getFps());

    return 1;
}

auto setfps(lua_State* L) -> std::intptr_t {
    auto taskScheduler{ TaskScheduler::getSingleton() };
    taskScheduler->setFps(lua_tointeger(L, 1, 60));

    return 1;
}

auto clonefunction(lua_State* L) -> std::intptr_t {
    luaL_checktype(L, 1, LUA_TFUNCTION);
    Closure* cl = (Closure*)lua_topointer(L, 1);

    lua_clonefunction(L, 1);

    return 1;
}

auto loadstring(lua_State* L) -> std::intptr_t {
    auto execution{ Execution::getSingleton() };

    const std::string script = lua_tostring(L, 1);
	const std::string chunk = luaL_optstring(L, 2, "=Nihon");

    if (std::string(script).empty() || lua_type(L, 1) != LUA_TSTRING)
        return 0;

    const std::string& bytecode = Luau::compile(script, {}, {}, &execution->encoding);

    if (bytecode.at(0) == 0) {
        lua_pushnil(L);
        lua_pushstring(L, bytecode.c_str());

        return 2;
    }

    if (luau_load(L, chunk.c_str(), bytecode.c_str(), bytecode.size(), 0)) {
        lua_settop(L, 0);
        lua_pushnil(L);
        lua_pushstring(L, lua_tostring(L, -1));

        return 2;
    }

    return 1;
}

std::vector<std::string> httpCache = {};
auto httpget(lua_State* L) -> std::intptr_t {
	std::string url = lua_tostring(L, 1);
	bool doCache = luaL_optboolean(L, 2, false);

	if (std::string(url).empty() || lua_type(L, 1) != LUA_TSTRING)
		return 0;

	if (url.find("http") != 0) {
		luaL_error(L, "Invalid protocol specified (expected 'http://' or 'https://')");
		return 0;
	}

	for (auto& cache : httpCache) {
		if (cache.find(url) != std::string::npos) {
			lua_pushstring(L, cache.c_str());
			return 1;
		}
	}

	auto response = cpr::Get(
		cpr::Url{ url },
		cpr::Header{ {"User-Agent", "Roblox/WinInet"} }
	);

	if (HttpStatus::IsError(response.status_code)) {
		std::string Output = std::format("Response : %s - %s\n", std::to_string(response.status_code),
			HttpStatus::ReasonPhrase(response.status_code));

		lua_pushstring(L, Output.c_str());
		return 1;
	}

	if (doCache == true)
		httpCache.push_back(response.text);

	lua_pushstring(L, response.text.c_str());
	return 1;
}

auto iscclosure(lua_State* L) -> std::intptr_t {
    lua_pushboolean(L, lua_iscfunction(L, 1));
    return 1;
}

auto islclosure(lua_State* L) -> std::intptr_t {
    lua_pushboolean(L, lua_isLfunction(L, 1));
    return 1;
}

auto setidentity(lua_State* L) -> std::intptr_t {
    auto taskScheduler{ TaskScheduler::getSingleton() };
    taskScheduler->setIdentity(luaL_optinteger(L, 1, 8));

    return 1;
}

auto getidentity(lua_State* L) -> std::intptr_t {
    auto taskScheduler{ TaskScheduler::getSingleton() };
    lua_pushinteger(L, taskScheduler->getIdentity());

    return 1;
}

auto identifyexecutor(lua_State* L) -> std::intptr_t {
    lua_pushstring(L, std::format( "{} - {}", Config::Name, Config::Version ).c_str());

    return 1;
}

auto isloaded(lua_State* L) -> std::intptr_t {
    lua_pushboolean(L, true);
    return 1;
}

std::map<Closure*, Closure*> newcclosureMap;
auto newcclosureHandler(lua_State* L) -> std::intptr_t {
    const auto nargs = lua_gettop(L);

    void* realClosure = reinterpret_cast<void*>(newcclosureMap.find(clvalue(L->ci->func))->second);

    if (realClosure == nullptr)
        return 0;

    L->top->value.p = realClosure;
    L->top->tt = LUA_TFUNCTION;
    L->top++;

    lua_insert(L, 1);

    const char* error;
    const auto res = lua_pcall(L, nargs, LUA_MULTRET, 0);

    if (res && res != LUA_YIELD && (error = lua_tostring(L, -1), !std::strcmp(error, "attempt to yield across metamethod/C-call boundary")))
		return lua_yield(L, 0);

    return lua_gettop(L);
}

std::intptr_t closureCount{};
auto newcclosure(lua_State* L) -> std::intptr_t {
    ARG_CHECK(L, 1, 1, luaL_checktype(L, 1, LUA_TFUNCTION););

    if (lua_iscfunction(L, 1)) {
        lua_pushvalue(L, 1);
        return 1;
    }

    lua_ref(L, 1);
    lua_pushcclosure(L, newcclosureHandler, 0, 0);
    newcclosureMap[&luaA_toobject(L, -1)->value.gc->cl] = &luaA_toobject(L, 1)->value.gc->cl;

    return 1;
}

auto checkcaller(lua_State* L) -> std::intptr_t {
    ARG_CHECK(L, 0, 0);
    lua_pushboolean(L, (TaskScheduler::getSingleton()->getIdentity() > 3));
    return 1;
}

auto isrbxactive(lua_State* L) -> std::intptr_t {
    ARG_CHECK(L, 0, 0);
    lua_pushboolean(L, isRobloxActive());
    return 1;
}

auto mouse1press(lua_State* L) -> std::intptr_t {
    ARG_CHECK(L, 0, 0);
    if (isRobloxActive())
        mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);

    return 0;
}

auto mouse1release(lua_State* L) -> std::intptr_t {
    ARG_CHECK(L, 0, 0);
    if (isRobloxActive())
        mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);

    return 0;
}

auto mouse1click(lua_State* L) -> std::intptr_t {
    ARG_CHECK(L, 0, 0);
    if (isRobloxActive())
        mouse_event(MOUSEEVENTF_LEFTDOWN | MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);

    return 0;
}

auto mouse2press(lua_State* L) {
    ARG_CHECK(L, 0, 0);
    if (isRobloxActive())
        mouse_event(MOUSEEVENTF_RIGHTDOWN, 0, 0, 0, 0);

    return 0;
}

auto mouse2release(lua_State* L) -> std::intptr_t {
    ARG_CHECK(L, 0, 0);
    if (isRobloxActive())
        mouse_event(MOUSEEVENTF_RIGHTUP, 0, 0, 0, 0);

    return 0;
}

auto mouse2click(lua_State* L) -> std::intptr_t {
    ARG_CHECK(L, 0, 0);
    if (isRobloxActive())
        mouse_event(MOUSEEVENTF_RIGHTDOWN | MOUSEEVENTF_RIGHTUP, 0, 0, 0, 0);

    return 0;
}

auto keypress(lua_State* L) -> std::intptr_t {
    ARG_CHECK(L, 1, 1, luaL_checktype(L, 1, LUA_TNUMBER);)
	std::uintptr_t key = lua_tointeger(L, 1);

    if (isRobloxActive())
        keybd_event(0, (BYTE)MapVirtualKeyA(key, MAPVK_VK_TO_VSC), KEYEVENTF_SCANCODE, 0);

    return 0;
}

auto keyrelease(lua_State* L) -> std::intptr_t {
    ARG_CHECK(L, 1, 1, luaL_checktype(L, 1, LUA_TNUMBER););
    std::uintptr_t key = lua_tointeger(L, 1);

    if (isRobloxActive())
        keybd_event(0, (BYTE)MapVirtualKeyA(key, MAPVK_VK_TO_VSC), KEYEVENTF_SCANCODE | KEYEVENTF_KEYUP, 0);

    return 0;
}

auto mousemoverel(lua_State* L) -> std::intptr_t {
    ARG_CHECK(L, 2, 2, luaL_checktype(L, 1, LUA_TNUMBER););
    luaL_checktype(L, 2, LUA_TNUMBER);

    std::intptr_t x = lua_tointeger(L, 1);
    std::intptr_t y = lua_tointeger(L, 2);

    if (isRobloxActive())
        mouse_event(MOUSEEVENTF_MOVE, x, y, 0, 0);

    return 0;
}

auto mousemoveabs(lua_State* L) -> std::intptr_t {
    ARG_CHECK(L, 2, 2, luaL_checktype(L, 1, LUA_TNUMBER););
    luaL_checktype(L, 2, LUA_TNUMBER);

    std::intptr_t x = lua_tointeger(L, 1);
    std::intptr_t y = lua_tointeger(L, 2);

    if (isRobloxActive())
        return 0;

    std::intptr_t width = GetSystemMetrics(SM_CXSCREEN) - 1;
    std::intptr_t height = GetSystemMetrics(SM_CYSCREEN) - 1;

    RECT CRect;
    GetClientRect(GetForegroundWindow(), &CRect);

    POINT Point{ CRect.left, CRect.top };
    ClientToScreen(GetForegroundWindow(), &Point);

    x = (x + Point.x) * (65535 / width);
    y = (y + Point.y) * (65535 / height);

    mouse_event(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE, x, y, 0, 0);
    return 0;
}

auto mousescroll(lua_State* L) -> std::intptr_t {
    ARG_CHECK(L, 1, 1, luaL_checktype(L, 1, LUA_TNUMBER););
    std::intptr_t amt = lua_tointeger(L, 1);

    if (isRobloxActive())
        mouse_event(MOUSEEVENTF_WHEEL, 0, 0, amt, 0);

    return 0;
}

auto checkinstance(lua_State* L, std::intptr_t idx) -> bool {
    const char* t = luaL_typename(L, idx);
    return (strcmp(t, "Instance") == 0);
}

auto compare_instances(lua_State* L) -> std::intptr_t {
    ARG_CHECK(L, 2, 2, luaL_checktype(L, 1, LUA_TUSERDATA););
    luaL_checktype(L, 2, LUA_TUSERDATA);

    if (!checkinstance(L, 1)) {
        luaL_argerror(L, 1, "userdata<instance> expected");
        return 0;
    }

    if (!checkinstance(L, 2)) {
        luaL_argerror(L, 1, "userdata<instance> expected");
        return 0;
    }

    std::intptr_t instance_1 = DEREFERENCEPOINTER(lua_touserdata(L, 1));
    std::intptr_t instance_2 = DEREFERENCEPOINTER(lua_touserdata(L, 2));

    lua_pushboolean(L, (instance_1 == instance_2));
    return 1;
}

auto getpropvalue(lua_State* L) -> std::intptr_t {
    ARG_CHECK(L, 2, 2, luaL_checktype(L, 1, LUA_TUSERDATA););
    luaL_checktype(L, 2, LUA_TSTRING);

    if (!checkinstance(L, 1)) {
        luaL_argerror(L, 1, "userdata<instance> expected");
        return 0;
    }

    lua_getfield(L, 1, lua_tolstring(L, 2, nullptr));
    const char* data = lua_tolstring(L, -1, nullptr); lua_pop(L, 2);


    lua_pushstring(L, data);
    return 1;
}

auto setpropvalue(lua_State* L) -> std::intptr_t {
    ARG_CHECK(L, 3, 3, luaL_checktype(L, 1, LUA_TUSERDATA););
    luaL_checktype(L, 2, LUA_TSTRING);
    luaL_checkany(L, 3);

    if (!checkinstance(L, 1)) {
		luaL_argerror(L, 1, "userdata<instance> expected");
        return 0;
    }

    lua_setfield(L, 1, lua_tolstring(L, 2, nullptr));
    return 0;
}

struct connection_t {
	std::intptr_t object;
	void* orignal_object;
	std::intptr_t old_state;
};

std::unordered_map<std::intptr_t, connection_t> connections;

auto indexconnection(lua_State* L) -> std::intptr_t {
	return 0;
}

auto blankfunction(lua_State* L) -> std::intptr_t {
	return 0;
}

std::intptr_t getconnections(lua_State* L) {
	ARG_CHECK(L, 1, 1, luaL_checktype(L, 1, LUA_TUSERDATA););

	lua_getfield(L, 1, "Connect");
	lua_pushvalue(L, 1);
	lua_pushcclosurek(L, blankfunction, nullptr, 0, nullptr);
	lua_pcall(L, 2, 1, 0);

	const auto signal = *reinterpret_cast<std::intptr_t*>(lua_touserdata(L, -1));
	auto next = *reinterpret_cast<std::intptr_t*>(signal + Offset::signalNext);

	lua_createtable(L, 0, 0);
	std::intptr_t count{};

	while (next != 0) {
		if (connections.count(next)) {
			*reinterpret_cast<connection_t*>(lua_newuserdata(L, sizeof(connection_t), 0)) = connections[next];

			lua_createtable(L, 0, 0);
			lua_pushcfunction(L, indexconnection, 0);
			lua_setfield(L, -2, "__index");
			lua_pushstring(L, "table");
			lua_setfield(L, -2, "__type");
			lua_setmetatable(L, -2);
		}
		else {
			connection_t newConnection{};
			newConnection.orignal_object = lua_touserdata(L, 1);
			newConnection.object = next;
			newConnection.old_state = *reinterpret_cast<std::intptr_t*>(next + Offset::signalState);

			*reinterpret_cast<connection_t*>(lua_newuserdata(L, sizeof(connection_t), 0)) = newConnection;

			lua_createtable(L, 0, 0);
			lua_pushcfunction(L, indexconnection, 0);
			lua_setfield(L, -2, "__index");
			lua_pushstring(L, "table");
			lua_setfield(L, -2, "__type");
			lua_setmetatable(L, -2);

			connections[next] = newConnection;
		}

		lua_rawseti(L, -2, count++);
		next = *reinterpret_cast<std::intptr_t*>(next + Offset::signalNext);
	}

	lua_getfield(L, -2, "Disconnect");
	lua_pushvalue(L, -3);
	lua_pcall(L, 1, 0, 0);

	return 1;
}

auto debug_getconstants(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 1, 1);

	if (lua_isfunction(L, 1) == false && lua_isnumber(L, 1) == false) {
		luaL_argerror(L, 1, "function or number expected");
		return 0;
	}


	if (lua_isnumber(L, 1)) {
		lua_Debug ar;

		if (!lua_getinfo(L, lua_tonumber(L, 1), "f", &ar)) {
			luaL_error(L, "level out of range");
			return 0;
		}

		if (lua_iscfunction(L, -1)) {
			luaL_argerror(L, 1, "stack points to a C closure, Lua function expected");
			return 0;
		}
	}
	else {
		lua_pushvalue(L, 1);

		if (lua_iscfunction(L, -1)) {
			luaL_argerror(L, 1, "Lua function expected");
			return 0;
		}
	}

	Closure* cl = (Closure*)lua_topointer(L, -1);
	Proto* p = cl->l.p;
	TValue* k = p->k;

	lua_newtable(L);

	for (std::intptr_t i = 0; i < p->sizek; i++) {
		TValue* tval = &(k[i]);

		if (tval->tt == LUA_TFUNCTION) {
			TValue* i_o = (L->top);
			setnilvalue(i_o);
			L->top++;
		}
		else {
			TValue* i_o = (L->top);
			i_o->value = tval->value;
			i_o->tt = tval->tt;
			L->top++;
		}

		lua_rawseti(L, -2, (i + 1));
	}

	return 1;
}

auto debug_getconstant(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 2, 2);

	if (lua_isfunction(L, 1) == false && lua_isnumber(L, 1) == false) {
		luaL_argerror(L, 1, "function or number expected");
		return 0;
	}

	const std::intptr_t index = luaL_checkinteger(L, 2);

	if (lua_isnumber(L, 1)) {
		lua_Debug ar;

		if (!lua_getinfo(L, lua_tonumber(L, 1), "f", &ar)) {
			luaL_error(L, "level out of range");
			return 0;
		}

		if (lua_iscfunction(L, -1)) {
			luaL_argerror(L, 1, "stack points to a C closure, Lua function expected");
			return 0;
		}
	}
	else {
		lua_pushvalue(L, 1);

		if (lua_iscfunction(L, -1)) {
			luaL_argerror(L, 1, "Lua function expected");
			return 0;
		}
	}

	Closure* cl = (Closure*)lua_topointer(L, -1);
	Proto* p = cl->l.p;
	TValue* k = p->k;

	if (!index) {
		luaL_argerror(L, 1, "constant index starts at 1");
		return 0;
	}

	if (index > p->sizek) {
		luaL_argerror(L, 1, "constant index is out of range");
		return 0;
	}

	TValue* tval = &(k[index - 1]);

	if (tval->tt == LUA_TFUNCTION) {
		TValue* i_o = (L->top);
		setnilvalue(i_o);
		L->top++;
	}
	else {
		TValue* i_o = (L->top);
		i_o->value = tval->value;
		i_o->tt = tval->tt;
		L->top++;
	}

	return 1;
}

auto debug_setconstant(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 3, 3);

	if (lua_isfunction(L, 1) == false && lua_isnumber(L, 1) == false) {
		luaL_argerror(L, 1, "function or number expected");
		return 0;
	}

	const std::intptr_t index = luaL_checkinteger(L, 2);

	luaL_checkany(L, 3);

	if (lua_isnumber(L, 1)) {
		lua_Debug ar;

		if (!lua_getinfo(L, lua_tonumber(L, 1), "f", &ar)) {
			luaL_error(L, "level out of range");
			return 0;
		}

		if (lua_iscfunction(L, -1)) {
			luaL_argerror(L, 1, "stack points to a C closure, Lua function expected");
			return 0;
		}
	}
	else {
		lua_pushvalue(L, 1);

		if (lua_iscfunction(L, -1)) {
			luaL_argerror(L, 1, "Lua function expected");
			return 0;
		}
	}

	Closure* cl = (Closure*)lua_topointer(L, -1);
	Proto* p = cl->l.p;
	TValue* k = p->k;

	if (!index) {
		luaL_argerror(L, 1, "constant index starts at 1");
		return 0;
	}

	if (index > p->sizek) {
		luaL_argerror(L, 1, "constant index is out of range");
		return 0;
	}

	auto constant = &k[index - 1];

	if (constant->tt == LUA_TFUNCTION)
		return 0;

	const TValue* new_t = luaA_toobject(L, 3);
	constant->tt = new_t->tt;
	constant->value = new_t->value;

	return 0;
}

auto debug_getupvalues(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 1, 1);
	if (lua_isfunction(L, 1) == false && lua_isnumber(L, 1) == false) {
		luaL_argerror(L, 1, "function or number expected");
		return 0;
	}

	if (lua_isnumber(L, 1)) {
		lua_Debug ar;

		if (!lua_getinfo(L, lua_tonumber(L, 1), "f", &ar)) {
			luaL_error(L, "level out of range");
			return 0;
		}
	}
	else
		lua_pushvalue(L, 1);

	Closure* closure = (Closure*)lua_topointer(L, -1);
	TValue* upvalue_table = (TValue*)nullptr;

	lua_newtable(L);

	if (!closure->isC)
		upvalue_table = closure->l.uprefs;
	else if (closure->isC)
		upvalue_table = closure->c.upvals;

	for (std::intptr_t i = 0; i < closure->nupvalues; i++) {
		TValue* upval = (&upvalue_table[i]);
		TValue* top = L->top;

		top->value = upval->value;
		top->tt = upval->tt;
		L->top++;

		lua_rawseti(L, -2, (i + 1));
	}

	return 1;
}

auto debug_getupvalue(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 2, 2);
	if (lua_isfunction(L, 1) == false && lua_isnumber(L, 1) == false) {
		luaL_argerror(L, 1, "function or number expected");
		return 0;
	}

	if (lua_isnumber(L, 1)) {
		lua_Debug ar;

		if (!lua_getinfo(L, lua_tonumber(L, 1), "f", &ar)) {
			luaL_error(L, "level out of range");
			return 0;
		}
	}
	else
		lua_pushvalue(L, 1);

	const std::intptr_t index = luaL_checkinteger(L, 2);

	Closure* closure = (Closure*)lua_topointer(L, -1);
	TValue* upvalue_table = (TValue*)nullptr;

	if (!closure->isC)
		upvalue_table = closure->l.uprefs;
	else if (closure->isC)
		upvalue_table = closure->c.upvals;

	if (!index) {
		luaL_argerror(L, 1, "upvalue index starts at 1");
		return 0;
	}

	if (index > closure->nupvalues) {
		luaL_argerror(L, 1, "upvalue index is out of range");
		return 0;
	}

	TValue* upval = (&upvalue_table[index - 1]);
	TValue* top = L->top;

	top->value = upval->value;
	top->tt = upval->tt;
	L->top++;

	return 1;
}

auto debug_setupvalue(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 3, 3);
	if (lua_isfunction(L, 1) == false && lua_isnumber(L, 1) == false) {
		luaL_argerror(L, 1, "function or number expected");
		return 0;
	}


	const std::intptr_t index = luaL_checkinteger(L, 2);
	luaL_checkany(L, 3);

	if (lua_isnumber(L, 1)) {
		lua_Debug ar;

		if (!lua_getinfo(L, lua_tonumber(L, 1), "f", &ar)) {
			luaL_error(L, "level out of range");
			return 0;
		}
	}
	else
		lua_pushvalue(L, 1);

	Closure* closure = (Closure*)lua_topointer(L, -1);
	const TValue* value = luaA_toobject(L, 3);
	TValue* upvalue_table = (TValue*)nullptr;

	if (!closure->isC)
		upvalue_table = closure->l.uprefs;
	else if (closure->isC)
		upvalue_table = closure->c.upvals;

	if (!index) {
		luaL_argerror(L, 1, "upvalue index starts at 1");
		return 0;
	}

	if (index > closure->nupvalues) {
		luaL_argerror(L, 1, "upvalue index is out of range");
		return 0;
	}

	TValue* upvalue = (&upvalue_table[index - 1]);

	upvalue->value = value->value;
	upvalue->tt = value->tt;

	luaC_barrier(L, closure, value);
	lua_pushboolean(L, true);

	return 1;
}

auto debug_getprotos(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 1, 1, luaL_checktype(L, 1, LUA_TFUNCTION););

	if (lua_iscfunction(L, -1)) {
		luaL_argerror(L, 1, "stack points to a C closure, Lua function expected");
		return 0;
	}

	Closure* closure = (Closure*)lua_topointer(L, -1);

	lua_newtable(L);

	Proto* main_proto = closure->l.p;

	for (std::intptr_t i = 0; i < main_proto->sizep; i++) {
		Proto* proto_data = main_proto->p[i];
		Closure* lclosure = luaF_newLclosure(L, proto_data->nups, closure->env, proto_data);

		setclvalue(L, L->top, lclosure);
		L->top++;

		lua_rawseti(L, -2, (i + 1));
	}

	return 1;
}

auto debug_getproto(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 2, 3);
	luaL_checktype(L, 2, LUA_TNUMBER);

	bool active = luaL_optboolean(L, 3, false);

	if (lua_isnumber(L, 1)) {
		std::intptr_t level = lua_tointeger(L, 1);

		if (level >= L->ci - L->base_ci || level < 0)
			luaL_argerror(L, 1, "stack level out of range");

		lua_Debug ar;
		lua_getinfo(L, level, "f", &ar);

		if (clvalue(reinterpret_cast<CallInfo*>(L->ci - level)->func)->isC)
			luaL_argerror(L, 1, "stack level to a cclosure, lclosure expected");
	}
	else
		lua_pushvalue(L, 1);

	if (lua_isnumber(L, -1) == FALSE && lua_isfunction(L, -1) == FALSE) {
		luaL_argerror(L, 1, "function or level expected");
		return 0;
	}

	const auto function = clvalue(luaA_toobject(L, -1));

	if (!function->isC) {
		if (active)
			lua_newtable(L);

		const auto index = lua_tointeger(L, 2);

		if (index < 1 || index > function->l.p->sizep)
			luaL_argerror(L, 2, "proto index out of range");

		const auto proto = function->l.p->p[index - 1];

		setclvalue(L, L->top, luaF_newLclosure(L, proto->nups, function->env, proto));
		L->top++;

		if (active)
			lua_rawseti(L, -2, 1);
	}
	else
		luaL_argerror(L, 1, "lclosure expected");

	return 1;
}

auto debug_getstack(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 1, 2);
	luaL_checktype(L, 1, LUA_TNUMBER);

	const auto level = lua_tointeger(L, 1);
	const auto index = luaL_optinteger(L, 2, -1);

	if (level >= L->ci - L->base_ci || level < 0)
		luaL_argerror(L, 1, "level out of range");

	const auto frame = reinterpret_cast<CallInfo*>(L->ci - level);
	const auto top = (frame->top - frame->base);

	if (clvalue(frame->func)->isC)
		luaL_argerror(L, 1, "level points to a cclosure, lclosure expected");

	if (index == -1) {
		lua_newtable(L);

		for (std::intptr_t i = 0; i < top; i++) {
			setobj2s(L, L->top, &frame->base[i]);
			L->top++;

			lua_rawseti(L, -2, i + 1);
		}
	}
	else {
		if (index < 1 || index > top)
			luaL_argerror(L, 2, "stack index out of range");

		setobj2s(L, L->top, &frame->base[index - 1]);
		L->top++;
	}
	return 1;
}

auto debug_setstack(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 3, 3);
	luaL_checktype(L, 1, LUA_TNUMBER);
	luaL_checktype(L, 2, LUA_TNUMBER);
	luaL_checkany(L, 3);

	const auto level = lua_tointeger(L, 1);
	const auto index = lua_tointeger(L, 2);

	if (level >= L->ci - L->base_ci || level < 0)
		luaL_argerror(L, 1, "level out of range");

	const auto frame = reinterpret_cast<CallInfo*>(L->ci - level);
	const auto top = (frame->top - frame->base);

	if (clvalue(frame->func)->isC)
		luaL_argerror(L, 1, "level points to a cclosure, lclosure expected");

	if (index < 1 || index > top)
		luaL_argerror(L, 2, "stack index out of range");

	setobj2s(L, &frame->base[index - 1], luaA_toobject(L, 3));
	return 0;
}

auto debug_getinfo(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 1, 1);
	std::intptr_t level{};
	if (lua_isnumber(L, 1)) {
		level = lua_tointeger(L, 1);
		luaL_argcheck(L, level >= 0, 1, "level can't be negative");
	}
	else if (lua_isfunction(L, 1)) {
		level = -lua_gettop(L);
	}
	else {
		luaL_argerror(L, 1, "function or level expected");
		return 0;
	}

	lua_Debug ar;
	if (!lua_getinfo(L, level, "sluanf", &ar))
		luaL_argerror(L, 1, "invalid level");

	lua_newtable(L);

	lua_pushstring(L, ar.source);
	lua_setfield(L, -2, "source");

	lua_pushstring(L, ar.short_src);
	lua_setfield(L, -2, "short_src");

	lua_pushvalue(L, 1);
	lua_setfield(L, -2, "func");

	lua_pushstring(L, ar.what);
	lua_setfield(L, -2, "what");

	lua_pushinteger(L, ar.currentline);
	lua_setfield(L, -2, "currentline");

	lua_pushstring(L, ar.name);
	lua_setfield(L, -2, "name");

	lua_pushinteger(L, ar.nupvals);
	lua_setfield(L, -2, "nups");

	lua_pushinteger(L, ar.nparams);
	lua_setfield(L, -2, "numparams");

	lua_pushinteger(L, ar.isvararg);
	lua_setfield(L, -2, "is_vararg");

	return 1;
}

auto debug_getregistry(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 0, 0);
	lua_pushvalue(L, LUA_REGISTRYINDEX);
	return 1;
}

auto getbase(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 0, 0);
	lua_pushnumber(L, *reinterpret_cast<std::double_t*>(Rebase(0)));
	return 1;
}

auto dumpfunction(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 1, 1, luaL_checktype(L, 1, LUA_TFUNCTION););
	Closure* cl = (Closure*)lua_topointer(L, 1);
	lua_CFunction closure = cl->c.f;
	std::uintptr_t address = reinterpret_cast<std::uintptr_t>(closure);
	lua_pushnumber(L, *reinterpret_cast<std::double_t*>(Unbase(address)));
	return 1;
}

auto dumpcontinuation(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 1, 1, luaL_checktype(L, 1, LUA_TFUNCTION););
	Closure* cl = (Closure*)lua_topointer(L, 1);
	lua_Continuation closure = cl->c.cont;
	std::uintptr_t address = reinterpret_cast<std::uintptr_t>(closure);
	lua_pushnumber(L, *reinterpret_cast<std::double_t*>(Unbase(address)));
	return 1;
}

auto compile(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 1, 1, luaL_checktype(L, 1, LUA_TSTRING););
	std::string code = lua_tostring(L, 1);

	std::string bytecode = Luau::compile(code, {}, {}, &Execution::getSingleton()->encoding);

	lua_pushlstring(L, bytecode.c_str(), bytecode.size());
	return 1;
}

auto get_actor_state(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 1, 1, luaL_checktype(L, 1, LUA_TUSERDATA););
	std::intptr_t instance = DEREFERENCEPOINTER(lua_topointer(L, 1));

	std::intptr_t state = ((instance + 108) ^ *(int*)(instance + 108));

	lua_State* LL = reinterpret_cast<lua_State*>(state);

	lua_pushthread(LL);
	lua_xmove(LL, L, 1);

	return 1;
};

auto get_directory(const std::string& directory_name) -> std::filesystem::path {
	auto local_appdata = (std::filesystem::path(getenv("localappdata")) / Config::Name);

	if (!std::filesystem::exists(local_appdata))
		std::filesystem::create_directory(local_appdata);

	std::filesystem::path directory_path = local_appdata / directory_name;

	if (!std::filesystem::exists(directory_path))
		std::filesystem::create_directory(directory_path);

	return directory_path;
}

auto create_workspace() -> void {
	if (!std::filesystem::exists(Config::WorkspacePath))
		std::filesystem::create_directory(Config::WorkspacePath);
}

auto readfile(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 1, 1, luaL_checktype(L, 1, LUA_TSTRING);)
		std::string path = lua_tostring(L, 1);

	if (path.find("..") != std::string::npos) {
		luaL_error(L, "attempt to escape directory");
		return 0;
	}

	path = Config::WorkspacePath + path;

	if (!std::filesystem::exists(path.c_str())) {
		luaL_error(L, "file does not exist");
		return 0;
	}

	std::string output = readFile(path);
	lua_pushlstring(L, output.c_str(), output.size());
	return 1;
}

auto writefile(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 2, 2, luaL_checktype(L, 1, LUA_TSTRING);)
		luaL_checktype(L, 2, LUA_TSTRING);

	std::string path = lua_tostring(L, 1);
	std::string content = lua_tostring(L, 2);

	create_workspace();

	if (path.find("..") != std::string::npos) {
		luaL_error(L, "attempt to escape directory");
		return 0;
	}

	path = Config::WorkspacePath + path;

	std::ofstream out(path);
	out << content;
	out.close();

	return 0;
}

auto appendfile(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 2, 2, luaL_checktype(L, 1, LUA_TSTRING);)
		luaL_checktype(L, 2, LUA_TSTRING);

	std::string path = lua_tostring(L, 1);
	std::string content = lua_tostring(L, 2);

	if (path.find("..") != std::string::npos) {
		luaL_error(L, "attempt to escape directory");
		return 0;
	}

	path = Config::WorkspacePath + path;

	std::ofstream out;
	out.open(path, std::ios_base::app | std::ios_base::binary);
	out.write(content.c_str(), content.size());
	out.close();

	return 0;
}

auto loadfile(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 1, 1, luaL_checktype(L, 1, LUA_TSTRING);)
		std::string path = lua_tostring(L, 1);

	create_workspace();

	if (path.find("..") != std::string::npos) {
		luaL_error(L, "attempt to escape directory");
		return 0;
	}

	path = Config::WorkspacePath + path;

	if (!std::filesystem::exists(path.c_str())) {
		luaL_error(L, "file does not exist");
		return 0;
	}

	std::string output = readFile(path);
	Execution::getSingleton()->executeScript(output);

	return 0;
}

auto dofile(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 1, 1, luaL_checktype(L, 1, LUA_TSTRING);)
		std::string path = lua_tostring(L, 1);

	create_workspace();

	if (path.find("..") != std::string::npos) {
		luaL_error(L, "attempt to escape directory");
		return 0;
	}

	path = Config::WorkspacePath + path;

	if (!std::filesystem::exists(path.c_str())) {
		luaL_error(L, "file does not exist");
		return 0;
	}

	std::string output = readFile(path);
	Execution::getSingleton()->executeScript(output);
	return 0;
}

auto listfiles(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 1, 1, luaL_checktype(L, 1, LUA_TSTRING);)
		std::string path = lua_tostring(L, 1);

	create_workspace();

	if (path.find("..") != std::string::npos) {
		luaL_error(L, "attempt to escape directory");
		return 0;
	}

	path = Config::WorkspacePath + path;

	if (!std::filesystem::is_directory(path.c_str())) {
		luaL_error(L, "directory does not exist");
		return 0;
	}

	lua_newtable(L);

	std::intptr_t idx{};
	for (const auto& entry : std::filesystem::directory_iterator(path)) {
		auto file_path = entry.path().string();
		file_path = replace(file_path, Config::WorkspacePath, "");

		lua_pushinteger(L, ++idx);
		lua_pushstring(L, file_path.c_str());
		lua_settable(L, -3);
	}

	return 1;
}

auto isfolder(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 1, 1, luaL_checktype(L, 1, LUA_TSTRING);)
		std::string path = lua_tostring(L, 1);

	create_workspace();

	if (path.find("..") != std::string::npos) {
		luaL_error(L, "attempt to escape directory");
		return 0;
	}

	path = Config::WorkspacePath + path;

	lua_pushboolean(L, std::filesystem::is_directory(path));
	return 1;
}

auto isfile(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 1, 1, luaL_checktype(L, 1, LUA_TSTRING);)
		std::string path = lua_tostring(L, 1);

	create_workspace();

	if (path.find("..") != std::string::npos) {
		luaL_error(L, "attempt to escape directory");
		return 0;
	}

	path = Config::WorkspacePath + path;

	lua_pushboolean(L, std::filesystem::is_regular_file(path));
	return 1;
}

auto makefolder(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 1, 1, luaL_checktype(L, 1, LUA_TSTRING);)
		std::string path = lua_tostring(L, 1);

	create_workspace();

	if (path.find("..") != std::string::npos) {
		luaL_error(L, "attempt to escape directory");
		return 0;
	}

	path = Config::WorkspacePath + path;

	std::filesystem::create_directories(path);
	return 0;
}

auto delfolder(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 1, 1, luaL_checktype(L, 1, LUA_TSTRING);)
		std::string path = lua_tostring(L, 1);

	create_workspace();

	if (path.find("..") != std::string::npos) {
		luaL_error(L, "attempt to escape directory");
		return 0;
	}

	path = Config::WorkspacePath + path;

	if (!std::filesystem::remove_all(path)) {
		luaL_error(L, "folder does not exist");
		return 0;
	}

	return 0;
}

auto delfile(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 1, 1, luaL_checktype(L, 1, LUA_TSTRING);)
		std::string path = lua_tostring(L, 1);

	if (path.find("..") != std::string::npos) {
		luaL_error(L, "attempt to escape directory");
		return 0;
	}

	path = Config::WorkspacePath + path;

	if (!std::filesystem::remove(path)) {
		luaL_error(L, "file does not exist");
		return 0;
	}

	return 0;
}

auto gethui(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 0, 0);

	auto taskScheduler{ TaskScheduler::getSingleton() };

	std::uint16_t oldIdentity = taskScheduler->getIdentity();
	taskScheduler->setIdentity(8);

	lua_getglobal(L, "game");
	lua_getfield(L, -1, "GetService");

	lua_getglobal(L, "game");
	lua_pushstring(L, "CoreGui");

	lua_pcall(L, 2, 1, 0);

	taskScheduler->setIdentity(oldIdentity);

	return 1;
}

auto getclipboard(lua_State* L) -> std::intptr_t {
	if (!OpenClipboard(0)) {
		lua_pushnil(L);
		return 0;
	}

	const auto content = reinterpret_cast<const char*>(GetClipboardData(1));
	lua_pushstring(L, content);
	CloseClipboard();
	return 1;
}

auto setclipboard(lua_State* L) -> std::intptr_t {
	std::string text = lua_tostring(L, 1);

	if (!OpenClipboard(0)) {
		lua_pushnil(L);
		return 0;
	}

	EmptyClipboard();
	HGLOBAL memory = GlobalAlloc(GMEM_MOVEABLE, std::strlen(text.c_str()) + 1);
	if (!memory) {
		CloseClipboard();
		return 0;
	}

	std::memcpy(GlobalLock(memory), text.c_str(), std::strlen(text.c_str()) + 1);
	GlobalUnlock(memory);
	SetClipboardData(CF_TEXT, memory);
	CloseClipboard();
	GlobalFree(memory);

	return 0;
}

auto cache_invalidate(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 1, 1, luaL_checktype(L, 1, LUA_TUSERDATA););

	if (!checkinstance(L, 1)) {
		luaL_argerror(L, 1, "userdata<instance> expected");
		return 0;
	}

	DWORD instance = DEREFERENCEPOINTER((DWORD)lua_touserdata(L, 1));

	lua_pushlightuserdata(L, (void*)Address::robloxPushInstance);
	lua_gettable(L, LUA_REGISTRYINDEX);
	lua_pushlightuserdata(L, (void*)instance);
	lua_pushnil(L);
	lua_settable(L, -3);

	return 0;
}

auto cache_replace(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 2, 2, luaL_checktype(L, 1, LUA_TUSERDATA););
	luaL_checktype(L, 2, LUA_TUSERDATA);

	if (!checkinstance(L, 1)) {
		luaL_argerror(L, 1, "userdata<instance> expected");
		return 0;
	}

	if (!checkinstance(L, 2)) {
		luaL_argerror(L, 2, "userdata<instance> expected");
		return 0;
	}

	DWORD instance = DEREFERENCEPOINTER((DWORD)lua_touserdata(L, 1));
	lua_pushlightuserdata(L, (void*)Address::robloxPushInstance);
	lua_gettable(L, LUA_REGISTRYINDEX);
	lua_pushlightuserdata(L, (void*)instance);
	lua_pushvalue(L, 2);
	lua_settable(L, -3);

	return 0;
}

auto cache_iscached(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 1, 1, luaL_checktype(L, 1, LUA_TUSERDATA););

	if (!checkinstance(L, 1)) {
		luaL_argerror(L, 1, "userdata<instance> expected");
		return 0;
	}

	DWORD instance = DEREFERENCEPOINTER((DWORD)lua_touserdata(L, 1));

	lua_pushlightuserdata(L, (void*)Address::robloxPushInstance);
	lua_gettable(L, LUA_REGISTRYINDEX);
	lua_pushlightuserdata(L, (void*)instance);
	lua_gettable(L, -2);

	lua_pushboolean(L, !lua_isnil(L, -1));

	return 1;
}

std::vector<const char*> libraryNames = { "fluxus", "nihon", "syn" };

auto is_beta(lua_State* L) -> std::intptr_t {
	lua_pushboolean(L, false);
	return 1;
}

auto Environment::Register(lua_State* L) -> void {
    luaL_Reg coreFunctions[] = {
        {"getgenv", getgenv},
        {"getreg", getreg},
        {"gethui", gethui},

        {"getrawmetatable", getrawmetatable},
        {"setrawmetatable", setrawmetatable},
        {"setreadonly", setreadonly},
        {"isreadonly", isreadonly},
        {"iswriteable", iswriteable},
        {"is_writeable", iswriteable},
        {"makereadonly", makereadonly},
        {"make_readonly", makereadonly},
        {"makewriteable", makewriteable},
        {"make_writeable", makewriteable},
        {"getnamecallmethod", getnamecallmethod},
        {"setnamecallmethod", setnamecallmethod},

        {"newcclosure", newcclosure},
        {"iscclosure", iscclosure},
        {"islclosure", islclosure},
        {"checkcaller", checkcaller},

        {"loadstring", loadstring},
        {"HttpGet", httpget},

		{"getthreadidentity", getidentity},
        {"setthreadidentity", setidentity},

		// These don't want to work :pensive:
        {"getclipboard", getclipboard},
        {"setclipboard", setclipboard},

        {"identifyexecutor", identifyexecutor},
        {"is_loaded", isloaded},

        {"getfpscap", getfps},
        {"setfpscap", setfps},

        {"clonefunction", clonefunction},
        {"clonefunc", clonefunction},

        {"isrbxactive", isrbxactive},
        {"iswindowactive", isrbxactive},
        {"isgameactive", isrbxactive},

        {"keypress", keypress},
        {"keyrelease", keyrelease},
        {"mouse1click", mouse1click},
        {"mouse1press", mouse1press},
        {"mouse1release", mouse1release},
        {"mouse2click", mouse2click},
        {"mouse2press", mouse2press},
        {"mouse2release", mouse2release},
        {"mousescroll", mousescroll},
        {"mousemoverel", mousemoverel},
        {"mousemoveabs", mousemoveabs},

        {"checkinst", compare_instances},
        {"compareinstances", compare_instances},
        {"getpropvalue", getpropvalue},
        {"setpropvalue", setpropvalue},

		{"readfile", readfile},
		{"writefile", writefile},
		{"appendfile", appendfile},
		{"loadfile", loadfile},
		{"dofile", dofile},
		{"listfiles", listfiles},
		{"isfolder", isfolder},
		{"isfile", isfile},
		{"makefolder", makefolder},
		{"delfolder", delfolder},
		{"delfile", delfile},

        {nullptr, nullptr},
    };

    lua_pushvalue(L, LUA_GLOBALSINDEX);
    luaL_register(L, nullptr, coreFunctions);
    lua_settop(L, -(1) - 1);

	// Debug table
	lua_newtable(L);

	lua_pushcclosure(L, debug_getconstant, "debug.getconstant", 0);
	lua_setfield(L, -2, "getconstant");

	lua_pushcclosure(L, debug_getconstants, "debug.getconstants", 0);
	lua_setfield(L, -2, "getconstants");

	lua_pushcclosure(L, debug_getinfo, "debug.getinfo", 0);
	lua_setfield(L, -2, "getinfo");

	lua_pushcclosure(L, debug_getproto, "debug.getproto", 0);
	lua_setfield(L, -2, "getproto");

	lua_pushcclosure(L, debug_getprotos, "debug.getprotos", 0);
	lua_setfield(L, -2, "getprotos");

	lua_pushcclosure(L, debug_getstack, "debug.getstack", 0);
	lua_setfield(L, -2, "getstack");

	lua_pushcclosure(L, debug_getupvalue, "debug.getupvalue", 0);
	lua_setfield(L, -2, "getupvalue");

	lua_pushcclosure(L, debug_getupvalues, "debug.getupvalues", 0);
	lua_setfield(L, -2, "getupvalues");

	lua_pushcclosure(L, debug_setconstant, "debug.setconstant", 0);
	lua_setfield(L, -2, "setconstant");

	lua_pushcclosure(L, debug_setstack, "debug.setstack", 0);
	lua_setfield(L, -2, "setstack");

	lua_pushcclosure(L, debug_setupvalue, "debug.setupvalue", 0);
	lua_setfield(L, -2, "setupvalue");

	lua_pushcclosure(L, debug_getregistry, "debug.getregistry", 0);
	lua_setfield(L, -2, "getregistry");

	lua_setglobal(L, "debug");

	// Cache table
	lua_newtable(L);

	lua_pushcclosure(L, cache_invalidate, "cache.invalidate", 0);
	lua_setfield(L, -2, "invalidate");

	lua_pushcclosure(L, cache_replace, "cache.replace", 0);
	lua_setfield(L, -2, "replace");

	lua_pushcclosure(L, cache_iscached, "cache.iscached", 0);
	lua_setfield(L, -2, "iscached");

	lua_setglobal(L, "cache");

	// Nihon table
	lua_newtable(L);

	lua_pushcclosure(L, is_beta, "nihon.is_beta", 0);
	lua_setfield(L, -2, "is_beta");

	lua_setglobal(L, "nihon");

	for (const char* libraryName : libraryNames) {
		lua_getglobal(L, "nihon");
		lua_setglobal(L, libraryName);
	};

	if (Config::UseConsole)
		std::printf("  Registered Environment\n");
}